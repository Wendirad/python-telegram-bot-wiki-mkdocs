<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Performance Optimizations - python telegram bot wiki</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Introduction", url: "#_top", children: [
              {title: "Free Optimizations", url: "#free-optimizations" },
              {title: "Multithreading", url: "#multithreading" },
              {title: "Server location", url: "#server-location" },
          ]},
          {title: "What to read next?", url: "#what-to-read-next", children: [
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Webhooks/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Webhooks/" class="btn btn-xs btn-link">
        Webhooks
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Exception-Handling/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Exception-Handling/" class="btn btn-xs btn-link">
        Exception Handling
      </a>
    </div>
    
  </div>

    

    <h2 id="introduction">Introduction</h2>
<p>When your bot becomes popular, you will eventually want to improve response times. After all, Telegram places high priority on fast messaging. At the same time, responses become slower as more people are using your bot. This happens more quickly for inline bots, as they may receive multiple inline queries during one interaction. </p>
<p>There are of course many ways to tackle this problem. I'll talk extensively about two that, in my experience, get you the biggest "bang for the buck". The first is using threads to <em>handle requests asynchronously</em>, the second is <em>choosing a good server location.</em> But first, we'll look at optimizations that take very little effort.</p>
<h3 id="free-optimizations">Free Optimizations</h3>
<h4 id="ujson">ujson</h4>
<p>All communication with the Telegram servers is in JSON. Every message you send is JSON encoded, and every message you receive is JSON decoded. If you are using CPython, you can speed this up by installing the <a href="https://pypi.python.org/pypi/ujson">ujson</a> module.</p>
<h4 id="pypy">PyPy</h4>
<p><a href="http://pypy.org/">PyPy</a> is a different implementation of the Python programming language. Is your bot only using pure Python code? Using PyPy can then probably¹ optimize all your code -- free of charge. Do not use PyPy in combination with ujson.</p>
<p>¹PTB does <em>not</em> officially support PyPy as there have been a lot of issues in the past. It may still work out for you.</p>
<h3 id="multithreading">Multithreading</h3>
<h4 id="how-does-it-work">How does it work?</h4>
<p>The first thing you should know is that the <code>telegram.ext</code> submodule uses multithreading for the different tasks it carries out. <code>Updater</code>, <code>Dispatcher</code> and <code>JobQueue</code> each run in their own thread, separate from the main thread. This is mostly hidden from you, but not completely. For example, the <code>Updater.start_polling</code> and <code>start_webhook</code> methods are non-blocking, meaning that the execution of your script resumes after calling them (that's why you have to call <code>Updater.idle</code>).</p>
<p><strong>Note:</strong> This library uses the <a href="https://docs.python.org/3/library/threading.html"><code>threading</code></a> module for all concurrency. Because of the <a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global Interpreter Lock</a> (you don't need to know what that is), <strong>this does not actually make your code run faster</strong>. The real advantage is that I/O operations like network communication (eg. sending a message to a user) or reading/writing on your hard drive can run concurrently. These usually take very long, compared to the rest of your code (I'm talking &gt;95% here), and especially with networking there's a lot of waiting involved. </p>
<p>Still, when it comes to handling individual requests, no multithreading is used <strong>by default</strong>. All handler callback functions you register in the Dispatcher are executed in the <code>dispatcher</code> thread, one after another. So, if one callback function takes some time to execute, all other requests have to wait for it. </p>
<p><strong>Example:</strong> You're running the <a href="https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/echobot2.py">Echobot</a> and two users (<em>User A</em> and <em>User B</em>) send a message to the bot at the same time. Maybe <em>User A</em> was a bit quicker, so his request arrives first, in the form of an <code>Update</code> object (<em>Update A</em>). The Dispatcher checks the Update and decides it should be handled by the handler with the callback function named <code>echo</code>. At the same time, the <code>Update</code> of <em>User B</em> arrives (<em>Update B</em>). But the Dispatcher is not finished with <em>Update A</em>. It calls the <code>echo</code> function with <em>Update A</em>, which sends a reply to <em>User A</em>. Sending a reply takes some time (see <a href="#server-location">Server location</a>), and <em>Update B</em> remains untouched during that time. Only after the <code>echo</code> function finishes for <em>Update A</em>, the Dispatcher repeats the same process for <em>Update B</em>.</p>
<p>So, how do you get around that? Note that I said <strong>by default</strong>. To solve this kind of problem, the library provides a way to explicitly run a callback function (or any other function) in a separate thread. Before I show you how that looks, let's see how that affects the situation in our example. After you read this article, you marked the <code>echo</code> callback function to run in its own thread. Now, when the Dispatcher determined that the <code>echo</code> function should handle <em>Update A</em>, it creates a new thread with it as the target and <em>Update A</em> as an argument and starts the thread. Immediately after starting the thread, it repeats the process for <em>Update B</em> without any further delay. Both replies are sent <strong>concurrently</strong>. </p>
<h4 id="how-to-use-it">How to use it</h4>
<p>I don't want to bore you with <em>words</em> any further, so let's see some code! Sticking with the Echobot example, this is how you can mark the <code>echo</code> function to run in a thread:</p>
<p>At the beginning of your script, import <code>run_async</code>:</p>
<pre><code class="python">from telegram.ext.dispatcher import run_async
</code></pre>

<p>Then, use it as a decorator for the <code>echo</code> function:</p>
<pre><code class="python">@run_async
def echo(update, context):
    context.bot.send_message(update.message.chat_id, text=update.message.text)
</code></pre>

<p>Simple and straightforward, right? So, why did I bore you with all that stuff before?</p>
<h4 id="common-pitfalls">Common Pitfalls</h4>
<p>Sadly, programming with threads is rarely simple. There are lots of traps to fall into, and I'll try to give you a few hints on how to spot them. However, this wiki article does not replace ~~your psychiatrist~~ a university lecture on concurrency.</p>
<h5 id="shared-state">Shared state</h5>
<p>This is probably the biggest cause of issues with threading, and those issues are hard to fix. So instead of showing you how to fix them, I'll show you how to avoid them altogether. More about that later. </p>
<p><strong>A fair warning:</strong> In this section, I'll try to give you a simple talk (if that's possible) on a very complex topic. Many have written about it before, and I'm certainly less qualified than most. As usual, I'll use an example to complement the text, and try to stay in the realm of what's important to you. Please bear with me here.</p>
<p>An example that is often used to illustrate this is that of a bank. Let's say you have been hired by a bank to write a Telegram bot to manage bank accounts. The bot has the command <code>/transaction &lt;amount&gt; &lt;recipient&gt;</code>, and because many people will be using this command, you think it's a good idea to make this command asynchronous. ~~You~~ Some unpaid intern wrote the following (<strong>BAD AND DANGEROUS</strong>) callback function:</p>
<pre><code class="python">@run_async
def transaction(update, context):
  bot = context.bot
  chat_id = update.message.chat_id
  source_id, target_id, amount = parse_update(update)

  bot.send_message(chat_id, 'Preparing...')
  bank.log(BEGINNING_TRANSACTION, amount, source_id, target_id)

  source = bank.read_account(source_id)
  target = bank.read_account(target_id)

  source.balance -= amount
  target.balance += amount

  bot.send_message(chat_id, 'Transferring money...')
  bank.log(CALCULATED_TRANSACTION, amount, source_id, target_id)

  bank.write_account(source)
  bank.write_account(target)

  bot.send_message(chat_id, 'Done!')
  bank.log(FINISHED_TRANSACTION, amount, source_id, target_id)
</code></pre>

<p>I skipped some of the implementation details, so here's a short explanation:</p>
<ul>
<li><code>parse_update</code> extracts the user id's of the sender (<code>source_id</code>) and receiver (<code>target_id</code>) from the message</li>
<li><code>bank</code> is a globally accessible object that exposes the Python API of the banks operations</li>
<li><code>bank.read_account</code> reads a bank account from the bank's database into a Python object</li>
<li><code>bank.write_account</code> writes a bank account back to the bank's database</li>
<li><code>bank.log</code> must be used to keep a log of all changes to make sure no money is lost</li>
</ul>
<p>Sadly, ~~you~~ that damn intern fell right into the trap. Let's say there are two morally corrupt customers, <em>Customer A</em> with <em>Account A</em> and <em>Customer B</em> with <em>Account B</em>, who both make a transaction simultaneously. <em>Customer A</em> sends <em>Transaction AB</em> of <em>$10</em> to <em>Customer B</em>. At the same time, <em>Customer B</em> sends a <em>Transaction BA</em> of <em>$100</em> to <em>Customer A</em>.</p>
<p>Now the Dispatcher starts two threads, <em>Thread AB</em> and <em>Thread BA</em>, almost simultaneously. Both threads read the accounts from the database with the <strong>same</strong> balance and calculate a new balance for both of them. In most cases, one of the two transactions will simply overwrite the other. That's not too bad, but will at least be confusing to the customers. But threads are quite unpredictable and can be <a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">suspended and resumed by the operating system</a> at <em>any</em> point in the code, so the following order of execution can occur:</p>
<ol>
<li><em>Thread AB</em> executes <code>bank.write_account(source)</code> and updates <em>Account A</em> with <em>-$10</em></li>
<li>Before updating <em>Account B</em>, <em>Thread AB</em> is put to sleep by the operating system</li>
<li><em>Thread BA</em> is resumed by the operating system</li>
<li><em>Thread BA</em> executes <code>bank.write_account(source)</code> and updates <em>Account B</em> with <em>-$100</em></li>
<li><em>Thread BA</em> also executes <code>bank.write_account(target)</code> and updates <em>Account A</em> with <em>+$100</em></li>
<li>When <em>Thread AB</em> is resumed again, it executes <code>bank.write_account(target)</code> and updates <em>Account B</em> with <em>+$10</em></li>
</ol>
<p>In the end, <em>Account A</em> is at <em>+$100</em> and <em>Account B</em> is at <em>+$10</em>. Of course, this won't happen very often. And that's what makes this bug so critical. It will probably be missed by your tests and end up in production, potentially causing a lot of financial damage.</p>
<p><strong>Note:</strong> This kind of bug is called a <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a> and has been the source of many, many security vulnerabilities. It's also one of the reasons why banking software is not written by unpaid interns.</p>
<p>To be fair, you probably don't write software for banks (if you do, you should already know about this), but this kind of bug can occur in any piece of code that shares <em>state</em> across threads. While in this case, the shared state is the <code>bank</code> object, it can take many forms. A database, a <code>dict</code>, a <code>list</code> or any other kind of object that is modified by more than one thread. Depending on the situation, race conditions are more or less likely to occur, and the damage they do is bigger or smaller, but as a rule of thumb, they're bad.</p>
<p>There are many ways to fix race conditions in a multithreaded environment, but I won't explain any of them here. Mostly because it probably isn't worth the work; partly because it's cumbersome and I feel lazy. Instead, as promised in the first paragraph, I'll show you how to avoid them completely. That's not always as easy as it is in this case, but we're lucky:</p>
<ol>
<li>Our set of tools is very limited - <code>@run_async</code> is the only thread-related tool we're using</li>
<li>Our goals are not very ambitious - we only want to speed up our I/O</li>
</ol>
<p>There are two relatively simple steps you have to follow. First, identify those parts of the code that <strong>must</strong> run sequentially (the opposite of <em>in parallel</em> or <em>asynchronously</em>). Usually, that is code that fits <strong>at least one</strong> of these criteria:</p>
<ol>
<li><em>Modifies</em> shared state</li>
<li><em>Reads</em> shared state and <em>relies on</em> it being correct</li>
<li><em>Modifies</em> local state (eg. a variable used later in the same function)</li>
</ol>
<p>Make sure you have a good idea what <em>shared state</em> means. Don't hesitate to do a quick Google search on it. </p>
<p>I went through our bank example line by line and noted which of the criteria it matches, here's the result:</p>
<pre><code class="python">@run_async
def transaction(update, context):
  bot = context.bot
  chat_id = update.message.chat_id  # 3
  source_id, target_id, amount = parse_update(update)  # 3

  bot.send_message(chat_id, 'Preparing...')  # None
  bank.log(BEGINNING_TRANSACTION, amount, source_id, target_id)  # None

  source = bank.read_account(source_id)  # 2, 3
  target = bank.read_account(target_id)  # 2, 3

  source.balance -= amount  # 3
  target.balance += amount  # 3

  bot.send_message(chat_id, 'Transferring money...')  # None
  bank.log(CALCULATED_TRANSACTION, amount, source_id, target_id)  # None

  bank.write_account(source)  # 1
  bank.write_account(target)  # 1

  bot.send_message(chat_id, 'Done!')  # None
  bank.log(FINISHED_TRANSACTION, amount, source_id, target_id)  # None
</code></pre>

<p><strong>Note:</strong> One could argue that <code>bank.log</code> modifies shared state. However, logging libraries are usually thread-safe and it's unlikely that the log has a critical functional role. It's not being read from in this function, and I assume it's not being read from anywhere else in the code, so maybe consider this an exception to the rule. Also, for the sake of this example, it'd be boring if only <code>bot.sendMessage</code> would be safe to run in parallel. However, we will keep this in mind for the next step.</p>
<p>As you can see, there's a pretty obvious pattern here: <code>bot.sendMessage</code> and <code>bank.log</code> are not matching any criteria we have set for strictly sequential code. That means we can run this code asynchronously without risk. Therefore, the second step is to extract that code to separate functions and mark them with <code>@run_async</code>. Since our async code parts are all very similar, they can be replaced by a single function. We could have done that before, but then this moment would've been less cool. </p>
<pre><code class="python">@run_async
def log_and_notify(action, amount, source_id, target_id, chat_id, message):
  bank.log(action, amount, source_id, target_id)
  bot.send_message(chat_id, message)

def transaction(update, context):
  chat_id = update.message.chat_id  # 3
  source_id, target_id, amount = parse_update(update)  # 3

  log_and_notify(BEGINNING_TRANSACTION, amount, source_id, target_id, chat_id, 'Preparing...')

  source = bank.read_account(source_id)  # 2, 3
  target = bank.read_account(target_id)  # 2, 3

  source.balance -= amount  # 3
  target.balance += amount  # 3

  log_and_notify(CALCULATED_TRANSACTION, amount, source_id, target_id, chat_id, 'Transferring money...')

  bank.write_account(source)  # 1
  bank.write_account(target)  # 1

  log_and_notify(FINISHED_TRANSACTION, amount, source_id, target_id, chat_id, 'Done!')
</code></pre>

<p><strong>Note:</strong> You might have noticed that I moved <code>bank.log</code> before <code>bot.send_message</code>, so the log entries will be in order <em>most of the time</em>, assuming the database operations take long enough for the log to complete.</p>
<p><strong>Note:</strong> The <code>run_async</code> decorator can be placed on any function, not only handler callbacks. You can and should use this to your advantage.</p>
<p><strong>Note:</strong> It's likely that <code>bank.read_account</code> and <code>bank.write_account</code> require some I/O operations to interact with the banks database. You see that it's not always possible to write code asynchronously, at least with this simplified method. Read about <a href="https://en.wikipedia.org/wiki/Database_transaction">Transactions</a> to learn how databases solve this in "real life".</p>
<p>By separating the strictly sequential code from the asynchronous code, we made sure that no race conditions can occur. The <code>transaction</code> function won't be executed concurrently anymore, but we still managed to gain some substantial performance boost over completely sequential code, because the logging and user notification is now run in parallel.</p>
<p>At this point, let me say: <strong>Congratulations!</strong> :tada: and thank you for reading :grin: If you got this far without giving up, please consider a CompSci-related major at university, if you have that opportunity. If I left you with a question or two, post a message in our <a href="https://telegram.me/pythontelegrambotgroup">Telegram Group</a> and mention @jh0ker. If you found this easy to grasp and/or are eager to learn more about all that threading stuff, consider reading the <a href="https://docs.python.org/3/library/threading.html">documentation of the threading module</a> or learn about <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>, a modern and arguably better approach to asynchronous I/O that does not use multithreading.</p>
<p>As you may now have learned, writing good, thread-safe code is no exact science. A few last helpful guidelines for threaded code:</p>
<ul>
<li>Avoid using shared state whenever possible</li>
<li>Write self-contained (<a href="https://en.wikipedia.org/wiki/Pure_function">pure</a>) functions</li>
<li>When in doubt, make it sequential</li>
<li>Asynchronous functions return values encapsulated in a <a href="https://github.com/python-telegram-bot/python-telegram-bot/blob/master/telegram/utils/promise.py"><code>Promise</code></a></li>
</ul>
<h5 id="limits">Limits</h5>
<p>The maximum of concurrent threads is limited. This limit is 4 by default. To increase this limit, you can pass the keyword argument <code>workers</code> to the <code>Updater</code> initialization:</p>
<pre><code class="python">updater = Updater(TOKEN, workers=32)
</code></pre>

<p>If an asynchronous function is called from anywhere, including the Dispatcher, and the limit of concurrent threads is reached, the calling thread will block until one of the threads is done and a slot is free. <strong>Note:</strong> In version 4.3 and later, the calling thread will not block. The following is here for historic reasons.</p>
<p>This can lead to a so-called <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>, especially with nested function calls:</p>
<pre><code class="python">@run_async
def grandchild():
  pass

@run_async
def child():
  grandchild()

@run_async
def parent():
  child()
  child()
</code></pre>

<p>If you limited the maximum amount of threads to 2 and call the <code>parent</code> function, you start a thread. This thread calls the <code>child</code> function and starts another thread, so the amount of concurrent threads is 2. It now tries to call the <code>child</code> function a second time, but has to wait until the just started <code>child</code> thread ended. The <code>child</code> thread tries to call <code>grandchild</code>, but it has to wait until the <code>parent</code> thread ended. Now both threads are waiting for each other and blocking all other code that tries to run an asynchronous function. The calling thread (usually the Dispatcher) is effectively dead, hence the term <em>deadlock</em>.</p>
<h3 id="server-location">Server location</h3>
<p>All that multi-threading will only get you <em>so far</em>. Another potential bottleneck is the time your server (the computer that runs your bot script) needs to contact the Telegram server. As of <em>June 2016</em>, there is only one server location for the Bot API, which is in the Netherlands. </p>
<h4 id="test-your-connection">Test your connection</h4>
<h5 id="using-the-ping-utility">Using the ping utility</h5>
<p>You can test your connection by running <code>ping api.telegram.org</code> on the command line of your server. A good connection should have a stable ping of 50ms or less. A server in Central Europe (France, Germany) can easily archive under 15ms, a server in the Netherlands reportedly archived 2ms ping. Servers in the US, Southeast Asia or China are not recommended to host Telegram bots.</p>
<h5 id="using-the-curl-utility">Using the cURL utility</h5>
<p>While the <code>ping</code> utility is helpful and the information is valuable, it's a rather primitive way to test your connection. In reality, there are many factors that influence the response times of your bot. For a more detailed test that actually connects to the Telegram servers via HTTPS, you can use cURL. The following is taken from <a href="https://josephscott.org/archives/2011/10/timing-details-with-curl/">this blog post</a>.</p>
<h6 id="step-1">Step 1</h6>
<p>On the server you want to test, create a file called <code>curl-format.txt</code> and paste this:</p>
<pre><code>\n
            time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
</code></pre>

<h6 id="step-2">Step 2</h6>
<p>Make a request to the Telegram API. In the following command, replace <code>&lt;token&gt;</code> with your API token and <code>&lt;chat_id&gt;</code> with your User ID (you can get your User ID from <a href="https://telegram.me/userinfobot">@userinfobot</a>) and run it on your command line:</p>
<ul>
<li>Linux: <code>curl -w "@curl-format.txt" -o /dev/null -s "https://api.telegram.org/bot&lt;token&gt;/sendMessage?chat_id=&lt;chat_id&gt;&amp;text=Test"</code></li>
<li>Windows: <code>curl -w "@curl-format.txt" -o NUL -s "https://api.telegram.org/bot&lt;token&gt;/sendMessage?chat_id=&lt;chat_id&gt;&amp;text=Test"</code></li>
</ul>
<p>The result should look similar to this:</p>
<pre><code>    time_namelookup:  0,004
       time_connect:  0,041
    time_appconnect:  0,119
   time_pretransfer:  0,119
      time_redirect:  0,000
 time_starttransfer:  0,156
                    ----------
         time_total:  0,156
</code></pre>

<p><strong>TODO:</strong> Interpreting and improving these numbers.</p>
<p><strong>Note:</strong> When choosing a server for the sole purpose of hosting a Telegram bot, these (ping and cURL) are the only relevant timings. Even if you are the only user of the bot, there is no advantage in choosing a server close to <em>you.</em> </p>
<p>If you need some suggestions on where to host your bot, read <a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Where-to-host-Telegram-Bots">Where to host Telegram Bots</a>.</p>
<h2 id="what-to-read-next">What to read next?</h2>
<p>Learn <a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Webhooks">how to use webhooks</a> to get every last bit of performance from your bot.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../Webhooks/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../Webhooks/" class="btn btn-xs btn-link">
        Webhooks
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Exception-Handling/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Exception-Handling/" class="btn btn-xs btn-link">
        Exception Handling
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="">Windmill Dark</a> theme by None (noraj).</p>
</footer>

</body>
</html>